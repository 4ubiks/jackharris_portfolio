# ETC Internship 2025
August 8th was my final day as a DevOps engineer intern with Electronic Theatre Controls (ETC). It's been an extremely informative summer, with lots of skills learned, lots of humility, and gratitude. This was my first *real* internship, and easily the largest company I've had the pleasure of working with. There were many ups and downs to the summer I spent in Middleton with ETC, and I'm going to outline some of my highlights and lowlights. Overall, I'm really glad to have spent time working here. ETC products have been a part of my life since I was seventeen years old, working as a lighting director for theatre shows back in high school. One of the first lighting consoles I used was an ETC Connect II, and my university's black box theatre currently uses an Ion. Source4 and Desire family fixtures have been in nearly every rig I've worked on, and working behind the scenes on the development and future design of new ETC technology was a wonderful opportunity. 

## What is DevOps?
DevOps is an interesting career path in the Computer Science umbrella. First, it's a very unappreciated and seemingly hidden field. I quickly begun to understood DevOps as a team centered around the idea that "The companies with the best DevOps teams have no idea they have a DevOps team". DevOps engineers are the technicians for a play. The audience never sees them, and the more out of sight they stay, the more the audience can be sucked into the magic of the show. However, if they aren't there, all turns to hell pretty quickly. DevOps focuses on the mantra of "Keep programmers programming". It's a career centered around autonomy and efficiency. A DevOps engineer will write code, maintain infrastructure, and create environments for programmers to use that they can feel comfortable and prepared using. I like to think of a chef in a kitchen. At a nice restaurant, the chef needs to be equipped with the proper tools, knives, utensils, and ingredients to cook their delicious meals to perfection each time, without fail. Think of the chef as your software engineer, and the DevOps engineers as the ones prepping the kitchen each morning before the restaurant opens. DevOps engineers are given a high-level overview of what their programmers need, and they find the best way to make it happen. 

## DevOps - a true hidden gem
DevOps is a particularly interesting field, primarily due to the lack of awareness and importance of DevOps engineers. As a fourth-year undergraduate in a computer science discipline, this summer was the first time I had spent any significant time in a DevOps field, learning the tools, methodology, or general daily taskflow. DevOps is not taught very heavily in schools, and many students graduate without much understanding of the DevOps world. While many of the tools a DevOps engineer will use every day are taught in the form of scripting languages, SDLC workflows, and some general Linux how-to's, there is not enough of a foundation to inform students about the significance of a DevOps engineer's role. 

I'm grateful that my university has spent some time encouraging the use of Git, as I was informed quickly by those around me that Git didn't seem to be a very popular tool that students were equipped with. And while I was decently well-versed in the Git framework, there were many other ideas that I hadn't been educated in. It's tough to gauge the tangible role of a university in that specific way, as it's a well-known truth that a university *cannot* supplement what's learned in a real job, but there are more tools that a university should lay a foundation of unerstanding. Regardless, it's a very hidden field with a strong potential for students who enjoy automation, scripting, and environment maintaining

## Job Security in DevOps
It's no secret that the tech job market is in a tricky place. With junior engineers sending thousands of applications into a bottomless void, just hoping that any company, somehow, grabs onto one, and the rise of agentic AI and instantaneous software development, finding a steady job is more difficult than ever for computer scientists and software engineers. However, DevOps might act as a light at the end of the tunnel for many aspiring engineers. While the application process may only be slightly less laborious, the job security of a DevOps engineer is undoubtable. Software Engineers will *always* need ways to optimize their systems, speed up their workflows, and fix what's gone wrong. Agentic AI is not going to replace DevOps workflows anytime soon. While it can instantaneously write scripts, generate detailed proposals, and assist in writing code, AI is useless without someone who can tell it what to do. It's like the old allegory, 
`
"It's not that it costs $10,000 to cut a wire, it costs $10,000 to know which wire to cut". 
`
AI is getting very good at what it is being built to do, and it's going to continue getting better. However, as an application environment grows, AI's direct applicability inversely shrinks. DevOps engineers monitor environments with hundreds of machines, dozens of different tools and workflow processes, and as of August 8th, 2025, there have yet to be successful examples of a fully AI-powered DevOps team. At this point in time, no tech company should be without AI tools. A good software engineer has integrated an agentic assistant to their programming workflows, and should use it as best they can. However, given the current state of AI, it should not be trusted to run completely independently. 

## 'Vibe Coding' and DevOps
It's been fascinating to watch the 'Vibe Coding' frenzy take off, and observing the garbage fires that have resulted from uneducated, self-proclaimed 'vibe coders' has been incredibly entertaining. A common misconception is that Vibe Coding will cut down the time it takes to build a successful app. It won't. It changes how you spend your time. At the technological dawn of SaaS, web applications, and other code-based user interfaces, the majority of time spent was writing your code. Debugging typically didn't take eons, and while a relevant and necessary part of application building, debugging was one of the later steps of the application process. 

Vibe coding presents a different approach, where an AI agent is tasked with building your app and giving you your foundation of code, and then you (either with or without the same AI agent) will personalize the application and tailor it to your needs. However, this is where the vast majority of time is spent, especially if the vibe coder does not have a programming background. When you don't write your own code, the debugging process is exponentially more complicated, because you're trying to understand not only the existing errors, but why your code is functioning at all. A non-vibe coder might spend 15 hours building an app, and 15 hours debugging. An inexperienced vibe coder will spend 1 hour building an app, and 29 hours debugging. 

It'll be interesting to see experienced programmers navigate to a vibe coding approach, as it could likely cut off the time to build an app, but not necessarily increase debugging time. Think of 1 hour to build an app, and 10-15 to debug. 

DevOps engineers don't necessarily have a threat of vibe coding serving as a replacement for what they do. While scripted tasks and quick fixes can utilize AI, environment maintaining and application management isn't quite feasible for AI systems yet. ETC manages *lots* of virtial environments, operating systems, tools, and servers. The DevOps team has changing requirements and a variety of different tasks that need to be completed in a particular way. 

For example, one of my projects for this summer was implementing a backend script that could clean up our Artifactory instance by deleting outdated scripts. I spent approximately one month developing an algorithm, working with the Artifactory API, and implementing a python script that did exactly what we wanted it to do. 

After I had finished it, I tried vibe-coding the same script, to see what might come from it. ChatGPT-4o confidently gave me a solution. However, it wasn't half of what I needed. I tried to refine it by describing some more detail, but the more refinements ChatGPT made, the sloppier and more jumbled the script became. I tried to approach this without the lessons that I'd learned in the last month, the specific tasks the script needed to accomplish, and the lessons learned from failed implementations. When you spend time in the weeds of scripting and programming, you learn things that can't be learned from a Google search or a ChatGPT query. If you vibe-code a solution to problems like this, you might get to a point where you alleviate the issue, but you'll walk away having learned absolutely nothing. 

It didn't take me a month to write 419 lines of code. A programmer can write 419 lines of code in a day, if they sit down and crank it out. It took a month to develop a working algorithm, research different data structure implementations, determine how to transform Artifactory into that data structure, implement it in Python, learn how to control a very poorly documented API, and troubleshoot. From the day I first opened the ticket for this project, I wrote approximately 21 different scripts and data sheets. I used Python, Bash, and even looked into Groovy. I rewrote scripts, rewrote my algorithm, spent hours refining different implementations, and even had to completely scrap a working prototype, because a flaw was found after seeing it run the first time. 95% of the scripts and algorithms I wrote for this project will never see the light of day. On the day I finished this project, my understanding of the algorithm, what language to use, the flow of the script, *everything* was very different from what it was on the day I begun. The problem with relying too heavily on AI is that on Day 1, you have an idea of where you think you should go. AI won't think analytically for you, it won't rationalize whether or not your idea is practical, and it won't tell you you're wrong (unless you specifically ask for it, in which it will ONLY tell you you're wrong). Vibe coding isn't a machete that you use to chop your way through the jungle, it's an airplane that flies you over it. While that might sound nice, when you don't cross through that jungle on your own, you don't learn how to fight for yourself, you don't learn to think critically, and you won't take risks to improve your skills, workflow, and analytical skills. 

DevOps requires a significant amount of rationality and analytics. AI tools aren't strong enough to reason, guide, or mentor you in programming. Developers, especially at the junior level, need to take risks, make mistakes, and grow in their skills. Vibe coding won't help a DevOps engineer succeed, it'll give short term satisfaction and long term regret.

## About ETC, and why DevOps matters here
Programmers use a variety of tools to develop their code. All of ETC's products have software written in C++. So, naturally, we maintain a lot of environments that cater well to that need. Developers use `cmake`, `gcc`, `Visual Studio`, and many other tools that are relatively catered towards a C++-based environment. 

Version control is one of the most important aspects of software development. ETC uses a variety of version control applications, including `GitLab`, `GitKraken`, `Perforce`, and `GitHub`. The majority of its applications used to rely on Perforce, but as technical ability grows and maintainability increases, most teams have migrated to `GitLab`. One of the current goals of ETC's DevOps team is to migrate *all* of Research and Development (R&D) to one version control platform. 

GitLab is the method of preferred control, primarily because of its built-in `CI/CD` features. When you have so many teams working on different projects and different components of one product, there needs to be a way to ensure they will all cohesively work together at the end. If you give a front-end developer and a back-end developer six months to build an application, and both of their applications are completely incompatible with each other, you've wasted six months. Continuous Integration (CI) ensures this won't happen. In GitLab, whenever code is pushed to a repository, a series of tests can be run to ensure the pushed code meets the standards of that repository. If there are any failures in any of the pipeline jobs, the user is informed of the error, and the code is not pushed. While many version control applications have this capability, GitLab builds these features right into the foundation of the platform. 

Given the significant teamwork that is required to produce the products ETC develops, there is a strong need of intuitive and clear product management software. This is done primarily using Confluence and Jira, two management and documentation applications. Jira houses all pending tasks and tickets that need to be completed. DevOps both uses Jira to track tickets, and maintains Jira company-wide. One of our recent findings centered around Jira and a requirements management application called Jama. Generally, the company's developers do not like Jama, they find it is not beneficial and causes a lot of unnecessary problems. So, the DevOps team is taking that feedback and spending time trying to find another alternative that will be more beneficial to the developers, without sacrificing any vital components to product development. 

## My work, as an intern
I was assigned a Jira dashboard that had tasks with an 'Intern' classification. On my first day, I was shown a Jira dashboard with 13 different tickets. I was given the chance to work on whichever of the 13 I was the most interested by, and check them off as the summer goes along. While they weren't *exclusively* intern tasks, they were simpler projects that a junior level developer could complete without too much supervision. By the end of the summer, I completed five, and other developers completed six, leaving only two tickets unassigned. 

### GitLab Mirror Script
The first project I tackled was a script that would run on ETC's `GitLab` instance, and monitor the status of mirroed repositories. A 'mirrored' repository is a codebase that either pushes its contents to another location, or pulls its contents from another location. Sometimes, these mirrors can fail, due to a variety of reasons. I wrote a script that would run, and return a URL of every repository that currently had a `failed` mirror state. This would allow humans to quickly access whatever repository was in a failed state, and fix the issue. The script was written in Ruby, and run in a GitLab Rails administrative console. I was unfamiliar with Ruby, and the administrative side of GitLab, so this gave me a great opportunity to learn two different things. 

Unexpectedly, I also got some experience with a bit of bug bounty hunting with this ticket. When I ran one of my iterations of the script, I got a very unexpected output in the Rails terminal:
![GitLab Mirror Repo Password](./gitlabMirror/potentialBug/spoof_user_password.jpg)

In the yellow box, you can see a user's *password* in plaintext. While the actual photo was configured as a PoC, I was able to uncover *multiple* user's credentials with this script, including ETC's GitLab administrator. I got the experience of writing a Bug Bounty report for GitLab's bug bounty, and worked with one of their bug testers. Sadly, the bug was written off, due to the credentials only being accessible via an administrative use of the GitLab console. 

Personally, I do not believe that meets the criteria for being written off, as a GitLab administrator could easily uncover the credentials of a domain administrator, but unfortunately, I have not had time to contest the decision.

### Artifactory Purge
This was my largest project this summer, and it took the majority of my time. The script is a backend algorithm to delete old / outdated files on an Artifactory instance with bloated storage. Developers will go into Artifactory, and mark repositories they wish to be removed with a 'PURGE' property. When the script runs, it will delete all artifacts that either have that property listed, or are nth-children of a repository with that property. It aims to clean up space and free up terabytes of Artifactory storage. 

The implementation ended up being a binary tree reversal, where the Artifactory instance is mapped into a binary tree and the purge property application is decided by traversing from a leaf to a tree, and deleting an object if a 'PURGE' property is found during the traversal. 

### LDAP for Linux
Many of ETC's services are run on Ubuntu Servers, and this script autonomously joins Ubuntu Servers to ETC's domain. LDAP stands for 'Lightweight Active Directory Protocol', a standard that allows computers to interact with Active Directory (AD) servers. LDAP for Linux will allow dynamic administrative access on Linux servers, rather than admins sharing a user to locally log onto a machine. Previously, DevOps admins were using a shared admin account to log onto a server. Now, the Ubuntu servers can be joined to a domain, where DevOps admins can log onto the boxes with *their* individual admin users. 

### Carallon Data Upload Automation
Carallon hosts a large database of fixture types that is used almost universally across lighting consoles. They upload this data to a SharePoint server, where ETC developers can log on and retrieve the zipped data. We like to host a copy of the latest third party data (npm, docker containerization, etc). This script will automously upload the latest Carallon data to Artifactory, where developers can pull fixture data from in-house, rather than externally. 

Currently, there is no way to remotely download something from Carallon's server. I'm currently in conversation with them about possible solutions, but if a user manually downloads the zipped folder, the existing python script will automatically upload it to Artifactory. 

### GitLab Project Token Rotation
Whenever  a developer pushes their newest code to a GitLab repository, a sequence of CI jobs are run through a pipeline. Many of these pipeline jobs require authentication tokens to allow different repositories to work with one another. An issue many developers currently face is their token management. GitLab tokens are set to expire after a certain period of time, primarily for security reasons. Many developers are losing track of their tokens, what exists, what doesn't, and when the time comes to re-authenticate, what to *actually* refresh. This script is a bash-based sequence of commands that runs in a CI-job, performing a `rotation` on an existing token. Rotating a token will refresh its authenticity, resetting the timer for when it will be set to expire. 

If a token is manually configured with an expiration date of `1 month from creation` and the token is rotated two weeks after creation, the expiration date will refresh to `1 month from rotation date`, postponing the time until the ticket expires. This is a small, but optimal fix to increase developer workflow time, and decrease any additional (and possibly unnecessary) token management. 

## Lowlights
Unfortunately, no job / position is without some cons. While the majority of my animosities with this summer have not been directly related to ETC, there are some things I wish had been done differently. It's always difficult to gauge how to judge lowlights, because while there are many things in life that are not ideal, I find it difficult to look down on anyone for something, if I couldn't imagine doing a better job myself. Similarly, there are *always* negatives you *could* focus on, but it's rarely beneficial or necessary to hyperfixiate on something that won't be an issue for me, 24 hours from now. 

### <u>Collaboration</u>
One unique thing about the R&D department of ETC - everyone gets an office. As a college student, it was initially very exciting to see that I was being given an office with a nameplate, my own private workspace, it felt official, and aided in the feeling of importance and belonging to a company. A company willing and able to provide its interns with an office space is one that definitely cares about *each* employee, which is wonderful. 

However, it can also create an isolating environment. I was luckily able to have an office adjacent to ETC's senior DevOps engineer, so asking questions and getting code feedback was very simple. However, that was about the extent of my interactions with people at work, and the result ended up being a fairly lonely summer. I spent the majority of my days in my workspace, tucked away in a corner, sometimes not even getting the chance to speak out loud, if my office-mate was out of office, or working from home. I personally thrive on collaboration and team dynamics, and would have loved more opportunity to work with other people, or other interns. There is also significant improvement in workflow speed and design optimization if multiple people are able to work together. Different perspectives offer unbiased, honest feedback. 

There are few things most programmers love more than their own code. I'm a victim of this, as are 99% of software engineers. Over a career in technology, many programmers will write exceptional code worth praising. However, for every one project with beautiful code, 10 projects with hideous, sloppy, and unforgiving code came with it. Writing bad code is inevitable as a software engineer, *especially* at an intern/junior level. Multiple people working together on one project help keep other engineers honest, and better refine each other's code. Intern 2 won't show any favoritism bias towards Intern 1's code. They'll spot the errors, identify bottlenecking processes, and find things to tweak *well* before they'll start giving compliments. To write good code, you need honest feedback, and you need to be told where you need to improve. Working in teams helps expedite that process. 

Outside of the software application, ETC did not encourage much collaboration with interns across departments. With the exception of one intern who I drove to work on most days, I did not get a chance to meet any of the other 28 interns that ETC hired for this summer. I organized an intern lunch on one Friday back in June, but aside from that, there was extremely limited mingling and interactions with interns. Most departments only hire one or two interns for the summer, so interaction and collaboration is difficult. It's not necessarily feasible to have a software engineer intern, a finance intern, and a HR intern all working together, but it still would have been neater if ETC encouraged more intern interactions, especially because the majority of interns had moved to Madison/Middleton from other areas of the country, and likely did not have much community outside of their 9-5 jobs. 

### <u>Tool Onboarding</u>
As mentioned before, some tools that a DevOps engineer will use are taught in university courses. However, *many* of them are not, and I found a big part of my first two weeks here was spent trying to wrap my head around what tools are used where. "What's Jama?", "Hold on, Jenkins? What?", or "I'm confused, who exactly uses GitLab?" were some common questions I circulated in my head throughout the first part of the summer. While the majority of these were eventually answered, some of them only started to make sense in the final days of my time in the office. I think (at least for DevOps) it would have been beneficial to have one (or more) of the DevOps engineers sit down for an hour or two on my first week and provide a general overview of their systems, what they use, and a high-level overview of their tools and integrations. 

While there is a variety of technical understandings and backgrounds in interns, it's better for an intern who already knows Jenkins to have their knowledge reinforced and to be given a lesson in how ETC uses Jenkins, rather than an intern go two months without understanding how that tool works. 

No intern can gain proficiency from a short onboarding session, and to truly *learn* a tool, you need to spend time using it. However, it's easier to approach something if you've been briefed on what it is, how it's used, and where it is used in ETC's scope. Otherwise, an intern could spend extensive time on a project, trying to get something specific to work, without realizing that a tool already exists to expedite the process, and a whole day that was spent working on a redundant tool could've been spent getting closer to finishing a task.

## Overall / What's Next?
This was a very informative summer. I was able to learn a variety of different languages, skillsets, frameworks, and tools. I'll be taking a lot of knowledge with me out the door and into my final year of undergraduate schooling. I don't think a fire was lit under me for DevOps engineering, but I was able to learn so much. I definitely see a future with ETC, even if not in a DevOps role. I've used ETC's products since I was a high schooler, so being able to now represent that company is incredibly fulfilling. I've had a newfound appreciation and admiration for the role of a DevOps team, and it'll be beneficial to approach my future tasks with an approach with influence from the practicality of a DevOps engineer.

This fall, I was invited to stay on part-time as a software engineer for the `Hog Family` software development team. This will be a dramatic shift in what I've been doing previously, but it'll unlock many more opportunities to learn, and be a firsthand influencer in the advancement of lighting control technology. Hog is a Linux-based operating system written in C++, running approximately 1.2 million lines of code. It's a very different beast from DevOps, but I believe it will be very fulfilling, and allow me to learn just as much in a different field. 
